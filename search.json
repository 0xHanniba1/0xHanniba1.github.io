[{"title":"2026-W02","url":"/2026/01/2026-W02/","content":"📅 本周概览 (Summary)\n\n一句话总结：本周是工具化思维与AI工作流标准化并行的一周。通过开发多个实用小工具（Mock服务、JSON转换、X插件）验证了“Claude Code系统化流程”的有效性，技术上覆盖了从开发到运维（Jenkins/Prometheus）的闭环；但在情绪管理和AI账号稳定性上遭遇挑战，需尽快建立抗风险机制。\n进度：\n\n开发产出： 完成 mock-service (FastAPI)、Web端JSON转断言工具、X(Twitter) 备注分组插件。\n运维/测试： 跑通 Prometheus+Grafana 监控、Jenkins+钉钉通知流，整理性能测试文档。\n方法论沉淀： 整理并实践了“Claude Code 系统化使用流程”及“PSB-guide”，验证了结构化开发对质量的提升\n个人成长： 完成简历大改版，接触 git worktree 与 tmux。\n\n\n\n\n📝 每日记录 (Daily Log)\n2026-01-05 (周一)\n\n随记：\n\n 完成 mock-service：一个基于 FastAPI 的轻量级 Mock 服务，支持通过管理页面动态配置接口规则，用于模拟第三方系统接口进行自动化测试\n 学习使用 tmux 分屏等\n 要大改简历，不能按照原来老旧的思路\n\n\n反思：\n\n做 agent：第一个版本用 claude agent sdk 搭，先跑起来再说\nClaude.md 到底如何使用\ncc写，codex测试：节约token 先写框架，再小模块填充\n\n\n\n2026-01-06 (周二)\n\n随记：\n\n 修改了简历\n 测试下众安\n Claude code 只会简单对话给需求，深入学习整理教程也有搞头\n 自媒体要做：公众号、微博、小红书、推特、抖音\n\n\n反思：\n\n刷手机真是浪费时间\n\n\n\n2026-01-07 (周三)\n\n随记：\n\n 做了一个 web 端 json 一键转 JS/python 断言\n 整理了一个系统性使用 Claude Code的流程\n git worktree\n\n\n反思：\n\n想跑通一下 cc系统性写项目，暂时没想到写什么；还是喜欢写些小工具\n\n\n\n2026-01-08 (周四)\n\n随记：\n\n 写了一个 X 的插件：主要是备注、分组\n 给 claude code 加了一个/command，指定中文写作风格\n\n\n反思：\n\n写 X 插件时按照系统性使用 Claude Code的流程文档操作了前面的准备阶段，项目太小后面没有按照文档。但是，后面测试改动了几个版本，体会到按照流程走的好处。明天重新按照流程走一遍\n想整一个工具箱Zkit-web：将工具都放上去\n\n\n\n2026-01-09(周五)\n\n随记：\n\n Prometheus + Grafana 部署使用\n 性能测试文档整理\n\n\n反思：一点事就影响了情绪，计划搁置\n\n2026-01-10(周六)\n\n随记：\n\n CI/CD 自动化通知配置指南 (钉钉/飞书)\n 性能测试文档整理\n .gitignore 模板\n 测试用例生成prompt\n\n\n反思：\n\nmd表格无法在网页里显示，1 个小时未解决！\n\n\n\n2026-01-11(周日)\n\n随记：\n\n 按照 PSB-guide 流程跑通了 UItest-Jenkins-ding，\n\n\n反思：\n\ntmd claude 又把我号封了！严重影响心情\n第一次按照较为全面的流程 vibe 一个项目，感觉确实不一样\n\n\n\n\n💡 本周复盘 (Weekly Review)\n\n\nKeep (继续保持)：\n\n以造代学：高频产出实战工具（Mock/JSON/X插件），验证了“需求驱动”的高效性。\n流程落地：从随意开发转向遵循 “Claude Code SOP” 和 “PSB-guide”，工程质量显著提升。\n\n\n\nImprove (需要改进)：\n\n情绪风控：减少因工具故障（封号）或琐事（MD表格）导致的心态崩坏，建立备选方案意识。\n时间熔断：遇到非核心样式问题（如1小时修表格），应强制止损，拒绝低效内耗。\n\n\n\nTry (下周尝试)：\n\n\nZkit-web 集成：将本周的零散小工具整合为 Web 平台，借此完整跑通系统化开发流程。\nAI 容灾方案：配置Codex 或其他模型作为 Claude 的 Plan B，确保生产力不中断。\n\n\n\n\n","tags":["2026zk"]},{"title":"2026-W03","url":"/2026/01/2026-W03/","content":"本周概览 (Summary)\n\n一句话总结：本周深度探索了 Claude Agent 开发与工作流（ApiFlowAgent 项目与 Brainstorm 插件结合），同时完成了网络分流与各种状态栏小工具（IP Monitor/养猫）的开发；但在高强度的 Token 消耗与复杂的全流程自动化探索中感到难以掌控，心态略有起伏，最终决定回归第一性原理重新审视接口自动化。\n进度：\n\n研发项目： 完成 ApiFlowAgent 初始版（MVP），但决定重构思路；开发并上线 Mac 状态栏工具 ip-monitor 和 养猫游戏。\n基础设施： 解决 Claude Code 封号/分流问题（配置住宅静态 IP）；修复 Codex 代理冲突问题。\n生活/理财： 完成国区 PayPal 注册及汇丰 One 网银开通。\n技能/学习： 复习 JMeter；初步掌握 Claude Agent SDK；探索 PSB-guide 与 Brainstorm 结合的敏捷开发流程。\n\n\n\n每日记录 (Daily Log)\n2026-01-12 (周一)\n\n随记：\n\n 安装插件/superpowers:brainstorm，更新到 PSB-guide 流程\n 使用/superpowers:brainstorm 写了一个 ip-monitor，ip 显示在状态菜单栏\n 学习了 JMeter\n 学习小火箭分流\n\n\n反思：\n\nJMeter 之前也学习过，现在也忘得差不多了。今天相当于复习了，但是没有整理操作文档。\nclaude code 封号搞怕了，想用静态 IP，但是太贵了；不然分流让刷推等主要流走其他节点—需要再考虑方案\n\n\n\n2026-01-13 (周二)\n\n随记：\n\n 面试那边要做 agent，回来学习 agent，第一次申请 claude api\n 用原始 api 写了个 agent demo，后面又用 sdk 写了个；后续再优化\n\n\n反思：\n\n/brainstorm 插件还行，但是只能把指定的 plan 拿来作为参考，要和 PSB-guide 流程结合起来，今天写 agent 没有 changelog ，后面就乱套了\n后续把/brainstorm 和 PSB-guide 结合成起来，整理输出一篇文档/\n\n\n\n2026-01-14 (周三)\n\n随记：\n\n 养猫游戏 在状态菜单栏奔跑\n 学习设置了分流，让 cluade 走住宅静态 ip\n\n\n反思：\n\n今天就搞养猫游戏了，token 限额了，半天 bug 没解决\n\n\n\n2026-01-15 (周四)\n\n\n随记：\n\n\n 终于是找到 codex 无法工作的问题，之前下载了个监控 token 的工具 Quotio，工具里开启了代理\n\n\n\n 养猫游戏调试完成，后续再看看找个好图标。\n\n\n 发现个 typora 主题，还可以https://theme.typora.io/theme/Phycat-Color/\n\n\n\n\n反思：\n\n能够基于Claude Agent SDK构建通用型测试Agent，利用多元化Skill解决复杂测试场景，并将智能分析能力深度集成至CI/CD流程，实现智能化全流程闭环。\n\n\n\n2026-01-16 (周五)\n\n随记：\n\n 开启项目 ApiFlowAgent，当前进度：完成了需求设计、AI 层、执行层、报告层和 CLI\n 注册了国区 PayPal\n 汇丰 one 到了，开通了网银，但是没找到怎么绑定 apple pay\n\n\n反思：\n\n将brainstorm skill 和 PSB-guide 流程结合起来了，后续整一个文档，例如按照敏捷开发思路先跑来(MVP化)，PSB-guide 只用来 changelog/project-status/spec；取两者的精华组合起来\n之前 debug 养猫游戏消耗太多 token 了，导致今天 ApiFlowAgent 进度慢了，后续看看 cc 写完了代码，让 codex 来测试验证，减少点 token 消耗？\n\n\n\n2026-01-17 (周六)\n\n随记：\n\n 完成了 ApiFlowAgent 初始版，后续得慢慢迭代\n 在 codex 安装了 brainstorm skill，试试看\n\n\n反思：\n\nApiFlowAgent 到后面感觉自己已经无法掌控了，还得多练\n目前无法掌控 agent接口自动化全流程，还是拆开来，基于第一性原理，接口自动化痛点是什么。但是有个要点，不能是单纯让AI 生成用例或者代码，需要流程化。agent 里最难的是自动生成用例，自动迭代，TDD 模式跑到没有错误为止。还是多次头脑风暴迭代后想一个好方法\n每天至少复现 x 上大佬分享skill 等内容\n\n\n\n2026-01-18 (周日)\n\n随记：\n\n 退回原有模式，重新开展接口自动化\n\n\n反思：\n\n最近一周心态有点不稳\n\n\n\n本周复盘 (Weekly Review)\n\nKeep (继续保持)：\n\n极强的行动力与工具化思维： 遇到痛点（如 IP 监控、工作流卡顿）能立即动手写脚本或插件解决，不仅停留在想，而是落实到了代码上。\n持续的工作流优化意识： 不断尝试将 /brainstorm 插件与 PSB-guide 流程融合，试图建立更标准化的 MVP 开发模式（Changelog + Spec）。\n第一性原理思考： 在 ApiFlowAgent 项目失控时，能及时止损，反思“接口自动化的本质痛点”，而不是盲目堆砌代码。\n\n\nImprove (需要改进)：\n\nToken 成本与收益控制： 在“养猫游戏” debug 上消耗过多 Token，导致主线项目进度受阻。需评估 Token 使用的优先级，非核心逻辑可尝试降级方案。\n文档沉淀习惯： 复习 JMeter 时未整理操作文档，导致知识复用率低；Agent 开发过程中的 Changelog 缺失导致了中期的混乱。\n心态管理： 本周后期因项目复杂度失控出现心态不稳，需接受“技术探索期的混沌状态”，避免急于求成。\n\n\nTry (下周尝试)：\n\n落地新工作流文档： 正式输出一篇关于 /superpowers:brainstorm 与 PSB-guide 结合的实操文档，固化“头脑风暴 -&gt; MVP 规划 -&gt; 状态追踪”的流程。\n策略调整： 尝试“Claude Code 写代码 + Codex 验证测试”的组合模式，降低 Token 消耗。\n回归 TDD 模式： 在接口自动化重构中，严格执行 TDD（测试驱动开发），先写断言/用例，再让 AI 生成代码，避免 AI 生成不可控的“幻觉代码”。\n微习惯养成： 每天复现一个 X (Twitter) 上大佬分享的 Skill 或 Prompt 技巧，保持技术敏感度。\n\n\n\n","tags":["2026zk"]},{"title":"2026-W04","url":"/2026/01/2026-W04/","content":"本周概览 (Summary)\n\n一句话总结：\n进度：\n\n每日记录 (Daily Log)\n2026-01-19 (周一)\n\n随记：\n\n 学习 skill 原理，reference+script+skill.md\n 写个RAG-demo，openAI api 购买搁置\n 把测试中的痛点拆解形成原子 skill\n\n\n反思：\n\n还是更喜欢在 claude 里用 skill，token 不足，后续用 codex 写代码\n\n\n\n2026-01-20 (周二)\n\n随记：\n\n 写一个 taxapp，复刻成功\n\n\n反思：\n\n明天继续回归 skill\n\n\n\n2026-01-21 (周三)\n\n随记：\n\n 生日🎂\n\n\n反思：\n\n休息休息，明天再学\n\n\n\n2026-01-22 (周四)\n\n随记：\n\n 将一些热门 githup 项目做成 skill\n codex 解除了网络限制，之前都不知道，现在也可以快乐地制作 skill 了\n 将 yt-dlp 做成快捷指令，更加方便了\n\n\n反思：\n\n继续找一些软件测试相关的 githup 项目，做成 skill\n得好好学习一下快捷指令\n\n\n\n2026-01-23 (周五)\n\n随记：\n\n Agent-browser skill 和 playwright-mcp\n yt-dlp 快捷指令进度显示舍弃\n python-testing-patterns skill\n npx ctx7 来安装 skill\n promptfoo 测试 prompt/api/agent\n\n\n反思：\n\n还是得把测试全流程跑通\n搞清楚测试 prompt 的原理\n\n\n\n2026-01-24 (周六)\n\n随记：\n\n 卸载 npm 方式安装的 cc，换成原生方式\n 出去玩耍\n\n\n反思：\n\n无～今天太疲惫 休息再说\n\n\n\n2026-01-25 (周日)\n\n随记：\n\n 使用 brainstorm 规划 skill 功能，再用 skill-creator 构建 skill；创建了 api-test-generator skill，后续根据需求不断迭代\n 学习 prompt、agent 测试流程\n\n\n反思：\n\n\nAI 测试的方向：\n1. 构建测试 Skill 库 - 把团队的测试经验沉淀为可复用的 Skill\n2. 人机协作 - Skill 处理重复性测试，人专注边界探索\n3. 持续演进 - 每次发现新问题就更新 Skill\n\n\n\n专用 Agent 架构 → 不需要了；通用 Agent + 专业 Skill → 正确路径\n\n\n\n\n本周复盘 (Weekly Review)\n\nKeep (继续保持)：\n*\nImprove (需要改进)：\n*\nTry (下周尝试)：\n*\n\n","tags":["2026zk"]},{"title":"2026-W05","url":"/2026/01/2026-W05/","content":"本周概览 (Summary)\n\n一句话总结：\n进度：\n\n每日记录 (Daily Log)\n2026-01-26 (周一)\n\n随记：\n\n 安装使用 clawdbot，整理一篇安装指南\n blog 里的图片上传到 githup.io 不显示了，明天看看\n\n\n反思：\n\n今天把 clawdbot 跑通踩了不少坑，但是有 AI辅助就轻松多了，搁以前肯定放弃了；所以说现在想学什么都很方便\n\n\n\n2026-01-27 (周二)\n\n随记：\n\n blog 图片显示问题是路径错了，截屏粘贴显示完全路径就没问题\n 钉钉接入 clawdbot，效果不搞好，代码是 cc 写的；飞书接入 clawdbot 没有调试成功\n\n\n反思：\n\n一股脑接入钉钉、飞书，没有确定自己想要什么\n\n\n\n2026-01-28 (周三)\n\n随记：\n\n 自己总想着造车，搞半天接入飞书失败；今天 githup 搜索到了有大佬已经写好了插件，让 cc 帮忙安装成功了。openAI 额度限制了，又开通了 MinMax\n hexo-theme 主体在原有的基础上加上搜索和目录功能，但是目录感觉有点鸡肋\n\n\n反思：\n\n明天想一下 hexo-theme 后续怎么搞\n还是看看测试全流程，整整 skill\n\n\n\n2026-01-29 (周四)\n\n随记：\n\n 直接在本地 hexo-theme 里增加了搜索功能，后续看看能否导出成新的主题\n 场景已跑通：Jenkins 构建结果通过 webhook 发送到飞书群，然后 clawdbot 对失败日志进行分析\n\n\n反思：\n\n我看到有人通过 cc 配置硬件玩，感觉也可以玩玩\n\n\n\n2026-01-30 (周五)\n\n随记：\n\n 整理了一份 llm-eval学习列表\n 今天搭建环境，调通 OpenAI 和 Claude API，理解核心参数含义\n\n\n反思：\n\nclawdbot 暂时停了，等后续有新玩法\n\n\n\n本周复盘 (Weekly Review)\n\nKeep (继续保持)：\n*\nImprove (需要改进)：\n*\nTry (下周尝试)：\n*\n\n","tags":["2026zk"]},{"title":"CI/CD 自动化通知配置指南 (钉钉/飞书)","url":"/2026/01/CI-CD-ding-feishu-notify/","content":"第一步：项目结构整理\n为了保持项目整洁，建议按照以下目录归档文件：\n\n在项目根目录下新建一个文件夹，命名为 scripts。\n将通知用的 Python 脚本（如 ding_notify.py 或 feishu_notify.py）放入该文件夹。\n根目录保留 Jenkinsfile 和 requirements.txt（如果有）。\n\n\n第二步：配置群机器人 (获取 Webhook)\n选项 A：钉钉 (DingTalk)\n\n进入钉钉群，点击右上角 群设置 -&gt; 智能群助手。\n点击 添加机器人 -&gt; 选择 自定义 (通过Webhook接入)。\n安全设置 (必选)：推荐选择 “自定义关键词”，填入 “构建通知” (或你脚本中定义的其他词)。\n完成添加，复制并保存 Webhook 地址 (重点是 access_token 部分)。\n\n选项 B：飞书 (Feishu/Lark)\n\n进入飞书群，点击右上角 设置 -&gt; 群机器人。\n点击 添加机器人 -&gt; 选择 自定义机器人。\n安全设置 (必选)：推荐选择 “关键词”，填入 “构建通知”。\n完成添加，复制并保存 Webhook 地址。\n\n\n第三步：脚本功能准备 (Python 逻辑)\n你需要准备的脚本应具备以下逻辑（无需贴代码，确认功能即可）：\n\n依赖库：使用 requests 库发送 HTTP 请求。\n获取 Token：优先从系统环境变量读取 Webhook 地址或 Token，也可以在脚本中设置默认值。\n状态判断：接收命令行传入的 SUCCESS 或 FAILURE 状态。\n\n成功：消息标头显示绿色，文案提示“构建成功”。\n失败：消息标头显示红色，文案提示“构建失败”。\n\n\n消息组装：包含项目名称、构建耗时、结束时间，以及跳转链接（Console 日志或测试报告）。\n发送请求：将组装好的 JSON 数据 POST 给机器人的 Webhook 地址。\n\n\n第四步：Jenkins 流水线集成 (Jenkinsfile 逻辑)\n在 Jenkinsfile 中配置以下流程：\n\nStage: 环境准备与测试\n\n检查环境：判断 venv 文件夹是否存在。\n创建环境：如果不存在，执行命令自动创建虚拟环境。\n激活环境：执行 source venv/bin/activate。\n安装依赖：安装 requests (发通知用) 和 selenium/pytest (测试用)。\n执行测试：运行自动化测试命令并生成报告数据。\n\n\nPost: 构建后操作 (通知核心)\n\n配置 success (成功块) 和 failure (失败块)。\n再次激活环境：在发送通知前，必须再次执行 source venv/bin/activate。\n执行脚本：调用 Python 脚本，并传入 Jenkins 的环境变量（任务名、构建URL、耗时等）。\n\n\n\n","tags":["测试"]},{"title":"高效学习","url":"/2025/09/Efficient-Learning/","content":"高效学习：构建知识的20条黄金法则\n学习的速度，很大程度上不取决于你多聪明，而取决于你如何组织知识。方法得当，学习效率可以提升数倍。以下20条法则是构建高效知识体系的基石，它们按照重要性排序，越靠前，越是人们容易犯错或收益越大的地方。本文假设你会使用&quot;间隔重复&quot;类工具（如Anki, SuperMemo等）进行复习。\n核心法则：让记忆变简单\n前16条法则都围绕一个核心思想：把知识变得简单好记。\n1. 理解之前，不要记忆\n这是最重要的一条法则。记忆你不理解的东西，是在做无用功。这就像一个不懂德语的人，试图背下一整本德语历史书。就算他做到了，他对历史本身还是一无所知，而且这个过程会耗费巨量的时间。\n在日常学习中，我们常常因为教材写得不好或者时间紧迫，就开始&quot;囫囵吞枣&quot;。这种行为不仅效率低下，而且学到的知识毫无价值，无法应用和推理。你必须先花时间去理解一个概念，搞清楚它的来龙去脉、前因后果，然后再去记忆相关的细节。\n• 行动指南： 遇到不理解的内容，停下来！去查资料、看视频、问老师，直到你真正弄懂为止。不要把希望寄托于&quot;背下来以后自然就懂了&quot;。\n2. 先学习，再记忆\n在记忆零散的知识点之前，你需要先建立一个&quot;全局观&quot;。想象一下拼图，如果你不看盒子上的成品图，而是直接拿起一块块碎片就想硬拼，那会非常困难。学习也是一样。\n你应该先通读相关章节，了解整个知识框架（比如&quot;内燃机的基本原理&quot;），在脑中形成一个简单的模型。然后，再把这个框架中的关键细节，制作成一个个具体的问答卡片来记忆（比如&quot;是什么推动了内燃机的活塞？&quot;）。这样，每个知识点都不是孤立的，而是有组织、有联系的，记忆起来会快得多。\n• 行动指南： 不要一上来就扎进细节。先快速浏览一遍材料，了解主题的整体结构和核心思想，然后再深入学习和记忆。\n3. 从基础开始，层层递进\n第二条法则提到的&quot;全局观&quot;或&quot;知识框架&quot;，一开始越简单越好。不要试图一下子掌握一个复杂而精细的模型。从一个最简化的版本开始，然后在这个基础上慢慢添砖加瓦。\n永远不要轻视基础知识。即使它们看起来显而易见，也值得花时间去记忆。因为基础知识是我们构建更复杂知识的基石。忘记一个基础概念，可能会导致建立在其上的一整套知识体系的崩塌。而记忆基础知识的成本非常低，它们通常很简单，复习几次就能牢牢记住。相比之下，你学习中50%的时间，可能都花在了攻克那最难的3-5%的知识上。在基础上多花一点时间，绝对是稳赚不赔的投资。\n• 行动指南： 无论学习什么新领域，都从最核心、最基础的概念开始。确保你对这些基础了如指掌，再去挑战更高级的内容。\n4. 坚守&quot;最小信息原则&quot;\n这是将复杂知识变简单的核心技术。它的意思是，你制作的每一个记忆卡片，都应该尽可能只包含一条最小化的信息。\n为什么简单才好记？ • 单一路径： 记忆一个简单的知识点，大脑每次回忆时激活的神经通路几乎是固定的。这就像在一条路上反复走，路会越走越清晰。而复杂的知识点，每次回忆时大脑走的路径可能都不同，各种信息互相干扰，记忆就很难稳固。 • 精准复习： 如果一个卡片包含两个知识点（A和B），其中A简单，B困难。为了记住B，你不得不按照B的复习频率来频繁复习整个卡片，这就浪费了复习A的时间。把它们拆开，A和B就可以各自按照自己的最优间隔来复习，大大节省时间。\n• 糟糕的例子（复杂）： 问：死海有哪些特征？ 答：死海是位于以色列和约旦边界的盐湖，海岸线是地球最低点（-396米），长74公里，含盐量是海洋的7倍（30%），高密度能让人浮起，因盐度太高只有简单生物能存活。\n• 优秀的例子（拆分后）： 问：死海位于哪里？ 答：以色列和约旦边界。 问：地球表面的最低点是哪里？ 答：死海的海岸线。 问：死海的平均海拔约多少？ 答：海平面以下400米。 问：死海的含盐量大约是海洋的多少倍？ 答：7倍。 问：为什么死海能让人浮起来？ 答：因为含盐量高（密度大）。 问：为什么死海被称为&quot;死&quot;海？ 答：因为高盐度使大多数生物无法生存。\n注意： 拆分后的问题和答案都非常简短。我们的目标是让每次回忆时，从大脑中提取的信息量最小化。长期来看，知识点越简单，记忆效果越好。\n5. 挖空填空，简单有效\n如果你觉得遵守&quot;最小信息原则&quot;很难，那就用&quot;挖空填空&quot;（Cloze Deletion）。这是一个能快速将书本知识转换成记忆卡片的强大工具。它指的是将一个句子中的关键词挖掉，让你去填充。\n• 例子： 原始句子：“1991年，苹果和IBM共同投资4000万美元成立了Kaleida公司，旨在创造一种多媒体编程语言Script X。”\n• 可以制作的挖空卡片： 问：1991年，…和IBM共同投资4000万美元成立了Kaleida公司。 答：苹果\n问：1991年，苹果和IBM共同投资…成立了Kaleida公司。 答：4000万美元\n问：…年，苹果和IBM共同投资4000万美元成立了Kaleida公司。 答：1991\n问：Kaleida公司的目标是创造一种名为…的多媒体编程语言。 答：Script X\n这种方法能让你轻松地从一段话中提取出多个、符合最小信息原则的知识点。\n6. 善用图像\n人脑的视觉处理能力远超语言处理能力，&quot;一图胜千言&quot;是有科学依据的。一张图片所包含的细节和信息，我们往往能毫不费力地记住。在学习中，尤其是在解剖学、地理、化学、历史等领域，善用图片可以极大地缩短学习时间。\n思维导图（Mind Map）之所以流行，也是因为它利用了大脑对图像和空间关系的强大记忆能力。\n• 行动指南： 在制作卡片时，想一想：“这个知识点能用一张图来表示吗？” 能用图就尽量用图。\n7. 运用助记技巧\n助记技巧（Mnemonic）是各种能让记忆变得更容易的&quot;花招&quot;。比如用谐音、编故事、首字母缩写等方法。这些技巧的效果惊人，一个普通人经过训练，也能记住一副扑克牌的顺序。\n但是，请记住：助记技巧解决的是&quot;快速记下&quot;的问题，而学习的真正瓶颈是&quot;长期留存&quot;。要实现长期记忆，你依然需要间隔重复。不过，在学习的初始阶段，尤其面对一些枯燥无味的信息时，助记技巧是你的得力助手。随着练习，使用助记技巧会逐渐变成一种下意识的习惯。\n8. 图片挖空\n和文字挖空类似，图片挖空（Graphic Deletion）是把图片的一部分遮盖起来，让你回忆被遮住的是什么。这在学习需要识别位置和部件的学科时极为有效。\n• 例子： • 解剖学： 用一张人体骨骼图，遮住&quot;肱骨&quot;，提问&quot;这里是什么？“。 • 地理学： 用一张世界地图，遮住巴西，提问&quot;这个国家是？”。\n同一张图片可以被用来制作几十个不同的卡片，每个卡片提问一个不同的部分，效率非常高。\n9. 避免集合\n集合（Set）是一堆无序的东西，比如&quot;请列出欧盟的所有成员国&quot;。这类问题非常难记，因为每次回忆时，你大脑里蹦出这些国家的顺序可能都不同，这严重干扰了记忆的巩固。\n• 解决方案： 把无序的集合，想办法转换成有序的列表（Enumeration）。比如，可以按照这些国家加入欧盟的时间顺序来记忆。\n• 糟糕的例子（集合）： 问：欧盟有哪些成员国（截至2002年）？ 答：（列出15个国家的名字）\n• 优秀的例子（转化为有序的历史线索）： 问：1952年，除了法国，还有哪些国家加入了欧洲煤钢共同体？ 答：德国、意大利和比荷卢三国。 问：1973年，哪三个国家一起加入了欧共体？ 答：英国、爱尔兰和丹麦。 …以此类推。\n通过这种方式，你不仅把一个巨大的集合拆分成了几个小问题，还顺便学习了欧盟扩张的历史，知识点之间建立了有意义的联系。\n10. 避免列表\n列表（Enumeration）虽然比集合好，但如果太长，依然是记忆的难点。比如背诵一首长诗或者一个长长的化学流程。\n• 解决方案： 使用重叠式挖空填空来拆解它。\n• 学习字母表的例子： 问：字母表的前三个字母是什么？ 答：A B C 问：请填上缺失的字母：A … C … E 答：B, D 问：请填上缺失的字母：B … D … F 答：C, E …\n这样，你每次只需要专注于一小段序列，而不是整个冗长的列表。在每次复习完一个小片段后，再完整地背诵一遍，你会发现整个过程变得轻松愉快。背诗也是同理，如果总在某一句卡壳，就把它和它的上一句、下一句做成挖空卡片来重点攻克。\n11. 对抗记忆干扰\n当你学习两个相似的东西时，它们很容易互相&quot;打架&quot;，让你混淆。比如，你可能分不清 historic（有历史意义的）和 historical（与历史有关的）的区别。这是遗忘最主要的原因之一。\n干扰的发生难以预测，最好的办法是在它造成严重问题之前，就主动预防和消除它。\n• 应对策略： • 让知识点更明确： 使用例子、图片、个人经历等来区分相似概念。 • 遵守最小信息原则： 知识点越简单，越不容易与其他信息混淆。 • 及时消除： 一旦发现自己混淆了两个知识点，立即把它们找出来，专门制作卡片来对比区分，不要拖延。\n12. 优化措辞\n卡片上问题的措辞，应该像一把精准的钥匙，能立刻打开你大脑中那把正确的锁。措辞必须简洁、明确、直指核心。\n• 糟糕的例子（啰嗦）： 问：1985年，Aldus公司凭借PageMaker开创了桌面出版。后来，由于未能改进，丹佛的哪家公司超越了它？ 答：Quark\n• 优秀的例子（精炼）： 问：在桌面出版领域，哪个公司超越了未能改进的PageMaker？ 答：Quark\n• 更好的例子： 问：PageMaker的市场输给了谁？ 答：Quark\n删除所有不必要的背景信息。这些额外信息只会拖慢你的反应速度，甚至产生干扰。如果其他信息也很重要，请把它们制作成单独的卡片。\n13. 关联其他记忆\n把新知识和你已经知道的东西联系起来，能极大地增强记忆。这能为新知识提供背景，减少干扰，并使其更容易被大脑&quot;接纳&quot;。\n• 例子（学习单词 cringing - 谄媚的）： • 不好的提问： （贬义词）形容无耻地意识到自己缺点并乞求的样子。 • 好的提问： （贬义词）形容一种无耻地谦卑（humble）和恳求（supplicant）的样子。\n如果你已经认识 humble 和 supplicant，用它们来解释 cringing，就能更快、更准确地锁定新词的含义。\n14. 个性化并提供实例\n将知识与你自己的生活联系起来，是最高效的记忆术之一。个人经历是独一无二的，能提供强大的记忆挂钩。\n• 例子（学习单词 divan - 沙发床）： • 不好的提问： 没有扶手和靠背的软床叫什么？ • 好的提问： 那种没有扶手和靠背的软床（就像我朋友小明家的那种）叫什么？\n如果你对小明家的那张沙发床有清晰的印象，这个个人化的例子会比任何抽象的定义都更容易记住。\n15. 借助情绪状态\n情绪能极大地增强记忆。能唤起你强烈情感（无论是喜悦、震惊、悲伤还是愤怒）的例子，都能让知识点变得更&quot;刻骨铭心&quot;。\n• 例子（学习单词 banter - 轻松的玩笑）： • 不好的提问： 一种轻松、开玩笑的交谈。 • 好的提问： 形容那种轻松、开玩笑的交谈（比如你看过的那部喜剧电影里主角和朋友的对话）。\n一个生动、带有情感色彩的例子，能帮你把抽象概念具体化，从而将学习时间缩短数倍。\n16. 使用情景提示\n为你的知识点添加一个简单的&quot;标签&quot;或&quot;前缀&quot;，来告诉大脑它属于哪个领域。这能帮助大脑快速进入正确的&quot;思维频道&quot;，避免混淆。\n• 例子： 缩写 GRE 可以指&quot;美国研究生入学考试&quot;，但在生物化学里指另一种东西。 • 不好的提问： 在生物化学中，GRE代表什么？ • 好的提问： 生化: GRE\n这个 生化: 的前缀就像一个开关，能瞬间把你的思维调整到生物化学的语境下，避免你先想到&quot;研究生考试&quot;，从而减少了反应时间和干扰。\n高级法则：优化与管理\n17. 适当的冗余是必要的\n“最小信息原则&quot;不等于&quot;信息量最少”。在某些情况下，适当的重复和补充是受欢迎的，甚至是必须的。\n• 主动与被动记忆： 学外语时，你不仅要能&quot;看英文说中文&quot;（被动），还要能&quot;看中文说英文&quot;（主动）。所以 phone -&gt; telefono 和 telefono -&gt; phone 这两张卡片都是必要的。\n• 补充推理过程： 在学习一个数学问题的解法时，你可以在答案中包含关键的推理步骤。这并非死记硬背，而是为了确保你每次都能沿着正确的逻辑路径思考。\n• 多角度理解： 对于一个非常重要的概念，从不同角度创建几个问题来记忆它，可以加深理解，确保在任何情况下都能回忆起来。\n18. 注明来源\n为你学到的知识注明出处。这在未来非常有用，比如当你发现不同来源的信息相互矛盾时，你可以追溯和判断哪个更可靠。来源还能在你需要深入研究或向他人证明时提供依据。来源信息应作为参考，一般不需要记忆。\n19. 标注日期\n知识是有保质期的。经济数据、科技知识、个人统计数据等都会随时间变化。为这些知识点加上日期或版本号，能提醒你它可能已经过时，需要更新。\n20. 明确优先级\n你永远不可能学完所有想学的东西。因此，分清主次至关重要。优先级贯穿于学习的整个过程：\n• 选择来源： 决定哪些书、文章或课程对你最重要。 • 提取知识： 从材料中挑选出最有价值的部分进行学习。 • 组织知识： 可以先把大量材料导入学习工具，然后根据优先级，逐步处理和优化成记忆卡片。 • 复习过程： 利用学习工具的功能，对特别重要或已更新的知识进行特殊处理（如提前复习、重新记忆、调整复习频率等），对不再重要或错误的知识进行忽略或删除。\n高效学习的关键，不仅在于努力，更在于明智地分配你的时间和精力。\n总结：20条黄金法则清单\n\n不懂就不学： 先求理解，再谈记忆。\n先学后记： 先建立全局观，再深入细节。\n从基础开始： 根基不牢，地动山摇。\n最小信息原则： 把知识拆到最简单。\n挖空填空： 制作卡片的利器。\n善用图像： 一图胜千言。\n运用助记技巧： 给枯燥的知识加点&quot;料&quot;。\n图片挖空： 地理、解剖学神器。\n避免集合： 把无序变为有序。\n避免列表： 用挖空填空拆解长列表。\n对抗干扰： 用例子和细节区分相似概念。\n优化措辞： 让问题像手术刀一样精准。\n关联旧知： 在已有知识上&quot;添砖加瓦&quot;。\n个性化实例： 你自己的经历是最好的记忆材料。\n借助情绪： 让情感为记忆赋能。\n情景提示： 用标签为大脑&quot;导航&quot;。\n适当冗余： 从不同角度巩固重要知识。\n注明来源： 知道你的知识从何而来。\n标注日期： 警惕知识的&quot;保质期&quot;。\n明确优先级： 把精力用在刀刃上。\n\n","tags":["x.com@dotey","学习"]},{"title":"系统性地使用Claude Code编写新项目","url":"/2026/01/PSB-guide/","content":"第一步：规划阶段（15-30 分钟）\n🌟现在安装了/superpowers:brainstorm 插件，可以直接在 Claude Code 里规划\n1.1 打开任意笔记工具，回答这两个问题\n问题 1：我到底想做什么？- 这是原型验证还是要上线？- 写一句话描述项目核心价值问题 2：MVP 包含哪些功能？- 列出 3-5 个核心功能- 其他功能放到 v1.1、v1.2\n1.2 让 AI 帮你理清思路\n打开 Claude，输入：\n我想做一个 [你的项目描述]。请问我 3 个最重要的问题，帮我理清没想明白的地方。\n认真回答这些问题，把答案记下来。\n1.3 生成项目规格文档\n继续让 Claude 帮你整理：\n基于我们的讨论，帮我生成一份项目规格文档，包含：1. 产品需求   - 解决什么问题   - 目标用户   - 核心功能列表（MVP）   - 用户交互流程2. 技术需求   - 技术栈选择（请用：[你偏好的技术栈，比如 Python + FastAPI + SQLite]）   - 项目结构建议   - 第三方服务/API\n把输出保存为 docs/spec.md。\n\n第二步：配置阶段（10-15 分钟）\n2.1 创建 GitHub 仓库\n# 创建并克隆仓库gh repo create my-project --private --clonecd my-project# 或者本地初始化mkdir my-project &amp;&amp; cd my-projectgit init\n2.2 创建目录结构\nmkdir docsmkdir .claudemkdir .claude/commands\n2.3 创建环境变量文件\ntouch .envtouch .env.exampleecho &quot;.env&quot; &gt;&gt; .gitignore\n在 .env 中提前填好所有 API key：\nOPENAI_API_KEY=xxxDATABASE_URL=xxx# 其他需要的 key...\n2.4 创建 CLAUDE.md（核心文件）\ntouch CLAUDE.md\n填入以下内容：\n# 项目名称一句话描述：[从 spec.md 复制]## 项目目标[MVP 要实现的 3-5 个核心功能]## 技术栈- 语言：Python 3.11- 框架：FastAPI- 数据库：SQLite- [其他...]## 项目结构src/  main.py  models/  routes/docs/tests/## 开发规范- 代码风格：[你的偏好]- 提交规范：feat/fix/docs 前缀- 测试要求：[有/无]## 约束条件- 不要使用 [某个你不想用的库]- 不要 [其他限制]## 当前状态见 [project-status.md](./docs/project-status.md)## 相关文档- [项目规格](./docs/spec.md)- [架构设计](./docs/architecture.md)- [变更日志](./docs/changelog.md)\n2.5 创建自动化文档\ntouch docs/architecture.md # 项目写完了再生成架构文档touch docs/changelog.mdtouch docs/project-status.md\ndocs/project-status.md 模板：\n# 项目状态## 已完成- [ ] 项目初始化## 进行中- [ ] [当前任务]## 待开始- [ ] [下一个任务]## 下次继续从这里开始：[具体描述]\n2.6 创建自定义命令（可选但推荐）\ntouch .claude/commands/update-docs.md\n内容：\n请更新以下文档以反映最新的代码变更：1. docs/architecture.md - 更新系统架构2. docs/changelog.md - 添加本次变更记录3. docs/project-status.md - 更新完成状态和下次继续点\n2.7 首次提交\ngit add .git commit -m &quot;init: 项目初始化&quot;git push -u origin main\n\n第三步：构建阶段\n3.1 启动 Claude Code\nclaude\n3.2 让 Claude 先熟悉项目\n请阅读 CLAUDE.md 和 docs/spec.md，确认你理解了项目目标和技术栈。\n3.3 进入计划模式（重要！）\n我要开始实现 [第一个功能]。请先进入 plan 模式，列出实现步骤，不要直接写代码。\n等 Claude 列出计划后，确认没问题再说：\n计划看起来没问题，请开始实现。\n3.4 每完成一个功能后\n/update-docs\n或者手动说：\n请更新 changelog.md 和 project-status.md，记录刚才的变更。\n3.5 遇到 Claude 犯错时\n立即在 CLAUDE.md 的约束条件里添加：\n## 约束条件- 不要使用 print 调试，用 logging- 不要把密钥硬编码  # ← 新增的规则\n\n完整流程图\n┌─────────────────────────────────────────────────────────┐│  第一步：规划（15-30分钟）                                 ││  ├─ 回答两个核心问题                                      ││  ├─ 让 AI 问你问题                                       ││  └─ 输出 spec.md                                        │└─────────────────────────────────────────────────────────┘                          ↓┌─────────────────────────────────────────────────────────┐│  第二步：配置（10-15分钟）                                 ││  ├─ 创建 GitHub 仓库             \t\t\t\t\t\t\t\t\t\t\t   ││  ├─ 配置 .env                                            ││  ├─ 创建 CLAUDE.md                                       ││  ├─ 创建 docs/ 文档                                      ││  └─ 首次提交                                             │└─────────────────────────────────────────────────────────┘                          ↓┌─────────────────────────────────────────────────────────┐│  第三步：构建（循环）                                      ││  ├─ 让 Claude 熟悉项目                                   ││  ├─ plan 模式列计划                                      ││  ├─ 确认后实现                                           ││  ├─ 更新文档                                             ││  └─ 犯错时添加规则                                        │└─────────────────────────────────────────────────────────┘\n","tags":["AI","Claude Code"]},{"title":"测试用例生成prompt","url":"/2026/01/Test-case-generation/","content":"任务目标\n为以下功能生成全面的测试用例\n功能描述\n“”&quot;\n[在此粘贴需求文本、用户故事或功能说明]\n“”&quot;\n补充信息\n接口定义（如有）\n[粘贴函数签名、API 定义、请求/响应结构]\n历史 bug 记录（如有）\n\n[简述历史上该模块或类似功能出过的典型问题]\n\n上下游依赖（如有）\n\n[列出依赖的外部服务、数据库、第三方接口及其可能的异常情况]\n\n分析步骤\n请严格按以下步骤分析，不要跳步：\n第一步：识别所有输入变量\n列出影响系统行为的所有因素：\n\n显式参数：函数入参、请求字段、表单输入\n隐式状态：用户登录态、数据库现有数据、配置开关\n环境因素：网络状况、系统时间、并发请求\n\n第二步：对每个变量做等价类划分\n用表格呈现：\n\n\n\n变量名\n有效等价类\n无效等价类\n边界值\n\n\n\n第三步：生成用例矩阵\n使用 pairwise 组合策略，确保任意两个变量的取值组合至少被一个用例覆盖。\n第四步：补充高风险场景\n基于补充信息中的历史 bug 和依赖关系，添加针对性用例。\n输出格式\n最终用例用 Markdown 表格输出，包含以下列：\n\n\n\nID\n测试模块\n前置条件\n测试步骤\n测试数据\n预期结果\n优先级\n\n\n\n优先级定义：\n\nP0：核心流程，阻塞发布\nP1：重要功能，需本迭代修复\nP2：边缘场景，可延后处理\n\n","tags":["测试"]},{"title":"autotest-idea","url":"/2026/01/autotest-idea/","content":"1.Jenkins 构建结果发给 clawdbot\n思路：\n\n实现：\n\n\n","tags":["测试"]},{"title":"使用 AI 学习","url":"/2025/08/autotest-notes/","content":"获取知识框架\n\n先用 Gemini DeepResearch 总结常见面试中会被问到的八股知识点。\n再交给 Claude Code 将这些知识点分解成系统性的知识框架。\n\n任务细化与层级提升\n\n把知识框架进一步拆解为微小的学习任务。\n在每个小任务中设计从初级到高级的过渡路径，逐步提升理解深度与应用能力。\n\n实践与模拟面试\n\n为每个小任务的知识点设计相应的代码练习，自己动手实现一遍，加深概念理解。\n模拟面试官的提问方式，边写边答，锻炼思维反应。\n\n","tags":["学习"]},{"title":"Clawdbot 安装配置指南","url":"/2026/01/clawdbot/","content":"简介\nClawdbot 是一个开源的个人 AI 助手，可以通过 Telegram、WhatsApp 等平台与 AI 模型交互，支持浏览器控制、文件操作等功能。\n1. 购买 VPS\n推荐 DMIT，选择 Los Angeles + Premium 网络，国内访问质量好。\n注意：开着代理时 SSH 可能无法连接，需要把 VPS IP 加到代理的直连规则中。\n\n2. 安装 Clawdbot\nSSH 登录 VPS 后执行：\n# 更新系统apt update &amp;&amp; apt upgrade -y# 一键安装curl -fsSL https://clawd.bot/install.sh | bash\n按提示完成初始配置（选择 AI 模型、认证方式等）。\n3. 访问 Web 管理页面\nClawdbot 默认只监听 localhost，需要通过 SSH 端口转发访问。\n在本地 Mac 终端执行（不是服务器）：\nssh -N -L 18789:127.0.0.1:18789 -i ~/Documents/DMIT-zktmac1-id_rsa/id_rsa.pem root@你的服务器IP\n然后在本地浏览器打开：http://localhost:18789/\n4. 配置 Telegram\n4.1 创建 Telegram Bot\n\n在 Telegram 搜索 @BotFather\n发送 /newbot，按提示设置名称和用户名\n复制获得的 Bot Token\n\n4.2 配置 Clawdbot\n在 VPS 上运行：\nclawdbot configure --section channels\n选择 Telegram，输入 Bot Token。\n4.3 添加授权用户\n在 Web 管理页面 → Channels → Telegram：\n\n点击 Allow From 旁边的 + Add\n添加你的 Telegram User ID\n\n\n4.4 完成配对\n在 Telegram 给 Bot 发送 /start，会收到配对码：\n\n在 VPS 上执行配对命令：\nclawdbot pairing approve telegram 你的配对码\n5. 模型选择\n\n\n\n方式\n优点\n缺点\n\n\n\n\nClaude API\n推理能力强\n价格较贵\n\n\nClaude OAuth\n用订阅额度\n有封号风险\n\n\nOpenAI API\n价格适中\n按量付费\n\n\nOpenAI OAuth\n用 Plus 额度\n配置稍复杂\n\n\n\n推荐使用 OpenAI OAuth，可以利用 ChatGPT Plus 订阅额度。\n在 Web 管理页面 → Config → Models 中配置：\n\n6. 后台运行\n# 安装 pm2npm install -g pm2# 启动并设置开机自启pm2 start clawdbotpm2 savepm2 startup\n常见问题\nQ: SSH 连接被关闭？\nA: 检查代理设置，把 VPS IP 加入直连规则。\nQ: Telegram 收不到回复？\nA: 确认已添加 User ID 到 Allow From，并完成 pairing approve。\n","tags":["AI","VPS","Telegram"]},{"title":"2026-W01","url":"/2026/01/daily-recoding/","content":"📅 本周概览 (Summary)\n\n一句话总结：本周主要完成了 Postman Mock 的学习与实操，并 vibe 出一个 mock-chrome-plugin，最大的挑战是从零上手 Mock 技术并快速产出可用工具。\n进度：\n\nPostman Mock 学习 ✅ Done\nmock-chrome-plugin 🚀 MVP 完成\nHK 开卡完成\n\n\n\n\n📝 每日记录 (Daily Log)\n2026-01-02 (周五)\n\n随记：\n\n 学习 postman mock\n vibe了一个mock-chrome-plugin\n\n\n反思：\n\nGemini 的学习辅导功能特别实用，讲解很详细，对刚开始学的人特别友好。\n\n\n\n2026-01-03 (周六)\n\n随记：\n\n 复习 postman mock，又实操了一遍\n 准备 HK 开卡\n 咸鱼找人gpt 军人认证\n\n\n反思：\n\nX的创作者收益增加，后续可以在X上输出，刚好去办张卡\n\n\n\n2026-01-04 (周日)\n\n随记：\n\n HK 一日游\n\n\n\n\n💡 本周复盘 (Weekly Review)\n\nKeep (继续保持)：\n\n学完即练的节奏，周五学 + 周六复习实操，知识留存率高\n善用 AI 工具辅助学习（Gemini 讲解）\n保持对新工具/新机会的敏感度（X 创作者收益）\n\n\nImprove (需要改进)：\n\n每日记录可以更结构化，比如区分「学习」「项目」「杂事」\n周末安排较松散，可提前规划好核心任务\n\n\nTry (下周尝试)：\n\n在 X 上发第一条技术/工具类内容，测试输出→反馈循环\n把 mock-chrome-plugin 完善一下，考虑是否值得公开分享\nHK 卡到手后，跑通一次完整的收款流程\n\n\n\n","tags":["2026zk"]},{"title":"gitignore模板","url":"/2026/01/gitignore/","content":"# Python__pycache__/*.py[cod]*.sobuild/dist/*.egg-info/*.egg# 虚拟环境venv/.venv/env/# IDE.idea/.vscode/*.swp*.swo# 测试/覆盖率.pytest_cache/.coveragehtmlcov/# 日志和临时文件*.log*.tmp.cache/# 环境变量和敏感信息.env.env.local*.pem*.keysecrets/# 系统文件.DS_StoreThumbs.db# AI 工具.cursor/.aider/.claude/.codex/.continue/.codeium/.tabnine/.sourcegraph/.cody/CLAUDE.md.github/copilot-*# AI 生成的临时/上下文文件*prompt.txt*context.md.ai_history/# 项目特定（按需调整）output/data/*.csv*.xlsx\n"},{"title":"Linux常用命令","url":"/2025/09/linux-cli/","content":"第一部分：基础技能 - 构建可信赖的测试环境\n根本问题： 如何确保我的测试环境是干净、正确、且可重复的？ 核心原则： 任何测试的有效性都建立在一个稳定且配置正确的环境之上。以下命令是构建和维护这种环境的基石。\nA. 文件系统：管理测试资产\n这是我们的数字化工作台，存放着代码、数据、日志和脚本。\n\n导航与检视 (我们在哪？这里有什么？)\n\npwd (Print Working Directory): 回答“我现在在哪里？”这个问题，获取当前位置的绝对路径。\nls -lah (List): 回答“这里有什么？”。 -l (长格式) 看权限和所有者，-a (所有) 看隐藏文件，-h (人类可读) 看文件大小。这是检查环境状态的第一步。\ncd (Change Directory): 切换工作空间，去往你需要操作的地方。\n\n\n创建与组织 (搭建工作区)\n\nmkdir -p &lt;路径&gt;: 创建目录。-p 选项能一次性创建多层嵌套的目录，非常适合组织测试结果，如 mkdir -p test_results/run_20250927。\ntouch &lt;文件名&gt;: 创建一个空文件，常用于脚本中创建锁文件或日志占位符。\n\n\n操作与管理 (移动和清理资产)\n\ncp -r &lt;源&gt; &lt;目标&gt;: 复制文件或目录。-r 用于递归复制整个目录，是准备测试数据的常用操作。\nmv &lt;源&gt; &lt;目标&gt;: 移动或重命名文件/目录。\nrm -rf &lt;文件/目录&gt;: 删除文件或目录。-r 递归删除，-f 强制执行。这是一个高风险操作，使用前请三思。\n\n\n精确定位 (大海捞针)\n\nfind &lt;路径&gt; -name &quot;&lt;模式&gt;&quot;: 在指定路径下根据名称、类型、修改时间等多种条件查找文件。\n\n测试场景: find /var/log -name &quot;*.log&quot; -mtime -1 -&gt; 查找过去24小时内被修改过的所有日志文件，是排查近期问题的利器。\n\n\n\n\n\nB. 权限管理：控制访问权限\n根本问题： 谁能对这个文件做什么？（读、写、执行） 这是导致自动化脚本失败最常见也最容易被忽略的原因之一。\n\nchmod (Change Mode): 修改权限。\n\n场景: 自动化脚本无法执行？ -&gt; chmod +x my_script.sh (为脚本添加执行权限)。\n两种模式:\n\n符号模式 (易读): u+x (为所有者增加执行权限), g-w (为用户组移除写权限)。\n八进制模式 (高效): 755, 644。755 通常用于目录和脚本，644 用于普通文件。\n\n\n\n\nchown (Change Owner): 更改文件/目录的所有者和所属组。\n\n场景: 被测应用无法写入日志？ -&gt; 检查日志目录的所有者是否为运行该应用的用户，如果不是，使用 chown -R app_user:app_group /var/log/app 修正。\n\n\n\n\n第二部分：核心技能 - 从数据中提取洞见\n根本问题： 系统出错了，日志里记录了什么？海量日志中，哪一句是关键信息？ 核心原则： 日志是系统行为的唯一事实来源。我们的任务不是“读”日志，而是“审问”日志，从中压榨出有价值的信息。\nA. 查看日志：初步侦查\n\ncat: 一次性显示整个文件（仅适用于小文件）。\nless: 查看大文件的正确方式。 交互式查看，支持搜索 (/) 和翻页，不消耗大量内存。\nhead/tail: 查看文件的开头/结尾。\ntail -f &lt;文件名&gt;: 实时问题分析的王者。 持续监控文件末尾的新增内容，可以将测试操作与系统日志输出实时关联。\n\nB. 过滤与分析：沙里淘金\n\ngrep (Global Regular Expression Print): 文本搜索的瑞士军刀。\n\n核心功能: 筛选包含特定模式的行。grep &quot;ERROR&quot; app.log。\n关键选项:\n\n-i: 忽略大小写。\n-C &lt;数字&gt; (Context): 显示匹配行的上下文，理解错误背景至关重要。\n-v (Invert): 反向匹配，排除无关信息。\n-r: 递归搜索目录。\n\n\n\n\nsed (Stream Editor): 行编辑器。 擅长对文本行进行批量替换、删除、插入。\n\n场景: sed 's/DEBUG/INFO/g' log.txt -&gt; 将日志中的 “DEBUG” 全部替换为 “INFO”，便于分析。\n\n\nawk (Aho, Weinberger, and Kernaghan): 列处理器。 擅长将一行文本分割成多个字段（列）并进行处理。\n\n核心能力: 将非结构化或半结构化的日志数据化。\n场景: 从访问日志中计算平均响应时间。 grep &quot;200 OK&quot; access.log | awk '&#123;sum+=$10&#125; END &#123;print sum/NR&#125;' -&gt; 筛选成功请求，并对第10列（响应大小）求和，最后打印平均值。\n\n\n\n\n第三部分：控制被测应用 - 管理进程生命周期\n根本问题： 我的应用启动了吗？它运行得怎么样？如何安全地启停它？ 核心原则： 建立一个“验证 -&gt; 观察 -&gt; 控制”的反馈回路来主动管理被测应用。\n\nps aux | grep &lt;应用名&gt;: 验证 (Verify) 进程是否存在、状态如何。这是测试开始前的第一步检查。\ntop: 观察 (Observe) 系统和进程的实时资源消耗（CPU、内存）。这是诊断性能问题的首选工具。\nkill: 控制 (Control) 进程的生命。\n\nkill &lt;PID&gt;: 发送 SIGTERM (15) 信号，请求进程“优雅地”退出。\nkill -9 &lt;PID&gt;: 发送 SIGKILL (9) 信号，强制终止进程。这是最后的手段。\n\n\n\n\n第四部分：高级诊断 - 深入性能与网络\n根本问题： 系统为什么慢？是 CPU、内存、磁盘还是网络的问题？API 调用为何失败？\nA. 系统性能剖析\n\n宏观监控 (发现症状):\n\nfree -h: 查看内存和交换空间使用情况。\nvmstat: 全面了解 CPU、内存、I/O 的动态。\niostat: 深入分析磁盘 I/O 性能。\n\n\n微观剖析 (定位病因):\n\nperf: 专家的终极武器，能直接定位到代码函数级别的性能瓶颈。\n\nperf stat &lt;命令&gt;: 快速获取一个操作的宏观性能指标。\nperf top: 实时查看消耗 CPU 最多的函数。\nperf record &amp; perf report: 记录详细数据并离线分析，找出导致性能问题的具体调用链。\n\n\n\n\n\nB. 网络诊断与测试\n\n基础连通性:\n\nping: 检查两台主机之间网络是否通畅。\ntraceroute: 显示数据包经过的路由路径，定位网络延迟点。\nnslookup: 验证域名解析是否正确。\n\n\n端口与连接:\n\nnetstat -lntp: 查看哪些进程在监听哪些 TCP 端口。验证服务是否成功启动并监听在正确端口上。\n\n\nAPI 交互:\n\ncurl: API 测试的命令行王者。 模拟各类 HTTP 请求。\n\n-X &lt;方法&gt;: 指定请求方法 (GET, POST, etc.)。\n-H &quot;&lt;头信息&gt;&quot;: 添加请求头 (e.g., “Content-Type: application/json”)。\n-d '&lt;数据&gt;': 发送请求体。\n-v: 显示详细的通信过程，用于调试。\n-o &lt;文件&gt;: 将响应输出到文件。\n\n\n\n\n安全文件传输:\n\nscp -r &lt;源&gt; &lt;目标&gt;: 在本地和远程服务器之间安全地复制文件/目录。用于部署构建包、上传测试数据、下载日志报告。\n\n\n\n","tags":["测试"]},{"title":"LLM API 核心参数详解：Temperature、Top_p 与 Max_tokens","url":"/2026/01/llm-eval-learn/","content":"\n目标：搭建环境，调通 OpenAI 和 Claude API，理解核心参数含义。产出：一个封装好的 llm_client.py，支持调用两家 API。\n\n核心原理：LLM 是个&quot;概率预测机&quot;\n当你问 LLM：&quot;天空是？&quot;的时候，它并不是直接想出&quot;蓝色&quot;这个词，而是在内部计算所有可能的下一个字的概率排行榜：\n\n\n\n候选词\n概率\n\n\n\n\n蓝色\n60%\n\n\n灰的\n20%\n\n\n广阔的\n10%\n\n\n绿色的\n0.01%\n\n\n…\n…\n\n\n\n以下三个参数，就是在控制怎么从这个排行榜里选词。\n1. Temperature（温度）：控制&quot;胆量&quot;\n定义：控制模型在概率排行榜上选择时的随机性。\n原理：\n\n低温 (0 ~ 0.3)：模型变得保守，放大高概率词的优势，几乎只选 No.1。\n高温 (0.7 ~ 1.0+)：模型变得狂野，把所有词的概率拉平（Flatten），低概率词也有机会被选中。\n\n费曼比喻：\n\ntemperature = 0.1 — 像一个严谨的会计。你问他在哪吃饭，他永远去评分最高的那一家。稳，但无聊。\ntemperature = 0.9 — 像一个喝醉的诗人。你问他在哪吃饭，他可能会指着路边摊甚至垃圾桶说&quot;试试这个&quot;。容易出错，但偶尔有惊世骇俗的创意。\n\n场景建议：\n\n\n\n场景\n推荐值\n原因\n\n\n\n\n写代码、提取 JSON、分析 Bug 等级\n0\n需要确定性\n\n\n生成测试数据、模拟用户多样化输入\n0.7+\n需要多样性\n\n\n\n2. Top_p（核采样）：控制&quot;候选池&quot;\n定义：不改变概率值，而是直接切断低概率的尾巴。也叫 Nucleus Sampling。\n原理：模型从高到低累加概率，直到累加值达到 p（比如 0.9），只有在这个范围内的词才会被考虑，剩下的直接扔掉。\n费曼比喻 — 招聘面试：\n\ntop_p = 1.0 — 任何人都可以来面试，包括完全不靠谱的人。\ntop_p = 0.1 — 只面试哈佛耶鲁毕业的（前 10% 的精英），绝对稳，但可能把&quot;乔布斯&quot;这种非传统天才拒之门外。\n\nTemperature vs Top_p\n\n\n\n维度\nTemperature\nTop_p\n\n\n\n\n作用方式\n调整概率分布的形状（扁平 or 尖锐）\n画一条线，切掉长尾\n\n\n类比\n调节音量旋钮\n设置入场门槛\n\n\n\n\n行业惯例：通常只调其中一个，不要同时调两个，否则效果难以控制。\n\n3. Max_tokens：控制&quot;话唠程度&quot;\n定义：限制模型**生成（Output）**的最大 Token 数量。\n注意点：\n\n不包括输入：这是指模型输出的字数上限。\n硬截断：如果模型话没说完就到了 max_tokens，它会戛然而止。\n惨案现场：你让它返回 JSON，结果 max_tokens 太小，返回了 &#123;&quot;status&quot;: &quot;succe...（后面没了），导致 json.loads() 直接报错。\n\nToken 换算参考：\n\n1 Token ≈ 0.75 个英文单词\n1 Token ≈ 0.5 ~ 0.8 个汉字（取决于模型的 Tokenizer）\n\n\n测试策略：API 调试阶段不要吝啬 max_tokens，设大一点（如 1024 或 4096），防止截断。\n\n","tags":["AI","LLM","API"]},{"title":"性能测试","url":"/2026/01/performance-testing-guide/","content":"一、性能测试是什么\n性能测试的核心目标是回答一个问题：系统能扛多大压力，瓶颈在哪里？\n它不是简单地&quot;压一下看看&quot;，而是通过科学的方法，找到系统的能力边界和优化方向。\n\n二、测试类型（按目的分）\n\n\n\n类型\n目的\n做法\n典型产出\n\n\n\n\n基准测试\n摸清系统正常能力\n单接口/单场景，逐步加压\n最大 TPS、RT 基线\n\n\n负载测试\n验证能否满足预期目标\n按目标值压（如 1000 TPS）\n通过/不通过\n\n\n压力测试\n找系统极限，什么时候崩\n持续加压直到崩溃\n极限值、崩溃表现\n\n\n稳定性测试\n长时间运行有无问题\n中等压力跑 2~24 小时\n内存泄漏、GC 问题\n\n\n容量测试\n当前配置能支撑多少用户\n阶梯加压 + 资源监控\n容量规划建议\n\n\n浪涌测试\n突发流量能否扛住\n瞬间拉高再降低\n系统恢复能力\n\n\n\n怎么选择测试类型？\n新系统上线前 → 基准测试 + 负载测试大促活动前 → 压力测试 + 容量测试  日常迭代   → 基准测试（回归）核心系统   → 稳定性测试秒杀场景   → 浪涌测试\n\n三、测试场景（按业务分）\n3.1 基础场景\n\n\n\n场景\n说明\n适用情况\n\n\n\n\n单接口测试\n对单个 API 压测\n性能摸底、问题定位\n\n\n单业务流程\n完整链路（如下单=查库存→创建订单→扣款）\n链路性能验证\n\n\n\n3.2 进阶场景\n\n\n\n场景\n说明\n关键点\n\n\n\n\n混合场景\n模拟真实流量比例\n接口比例要贴近生产\n\n\n秒杀/抢购\n瞬间高并发打同一资源\n集合点、库存一致性、限流\n\n\n大数据量\n处理大量数据（导出、批量）\n单请求处理能力、超时\n\n\n长连接\nWebSocket、消息推送\n连接数上限、心跳、断连\n\n\n文件上传下载\n大文件传输\n带宽、超时、断点续传\n\n\n\n3.3 混合场景设计示例\n电商网站真实流量比例：├── 首页浏览    40%├── 商品搜索    25%├── 商品详情    20%├── 加入购物车   8%├── 下单支付    5%└── 用户登录    2%\n混合场景的价值：单接口都没问题，混合起来可能有资源竞争。\n\n四、性能指标体系\n4.1 业务指标（用户视角）\n\n\n\n指标\n全称\n含义\n关注点\n\n\n\n\nRT\nResponse Time\n响应时间\nP90/P99 比平均值重要\n\n\nTPS\nTransactions Per Second\n每秒事务数\n业务处理能力\n\n\nQPS\nQueries Per Second\n每秒请求数\n接口吞吐量\n\n\n并发数\nConcurrency\n同时在处理的请求数\n系统承载能力\n\n\n错误率\nError Rate\n失败请求占比\n压力大了是否报错\n\n\n吞吐量\nThroughput\n单位时间处理的数据量\n网络/IO 能力\n\n\n\n响应时间的正确理解\n平均 RT = 100ms  ← 看起来不错？P90 RT = 150ms   ← 90% 的请求在 150ms 内P99 RT = 800ms   ← 有 1% 的请求要 800ms！结论：平均值会掩盖长尾问题，要看分位数\nTPS vs QPS\nTPS：一个事务可能包含多个请求（下单=查库存+扣款+创建订单）QPS：纯粹的请求数量接口压测一般说 QPS业务压测一般说 TPS\n4.2 系统资源指标（服务器视角）\n\n\n\n指标\n监控命令\n瓶颈信号\n可能原因\n\n\n\n\nCPU\ntop, vmstat\n持续 &gt; 80%\n计算密集、死循环、GC\n\n\n内存\nfree, top\n持续上涨不释放\n内存泄漏、缓存过大\n\n\n磁盘 I/O\niostat, iotop\niowait 高、util 100%\n大量读写、日志过多\n\n\n网络\niftop, netstat\n带宽打满、连接数耗尽\n数据量大、连接泄漏\n\n\n\nCPU 指标详解\n%user   - 用户态 CPU（应用代码）%system - 内核态 CPU（系统调用）%iowait - 等待 IO 的 CPU（磁盘慢）%idle   - 空闲 CPUiowait 高 → 瓶颈在磁盘，不是 CPUuser 高   → 瓶颈在应用代码\n内存指标详解\nused     - 已使用内存free     - 完全空闲buff/cache - 系统缓存（可回收）available - 实际可用 = free + 可回收的 cache看 available，不是 free\n4.3 中间件指标（组件视角）\n数据库（MySQL）\n\n\n\n指标\n含义\n关注点\n\n\n\n\nQPS/TPS\n查询和事务数\n数据库压力\n\n\n慢查询数\n超过阈值的 SQL\n需要优化的 SQL\n\n\n连接数\n当前连接 / 最大连接\n连接池是否够用\n\n\n锁等待\n行锁、表锁等待时间\n并发冲突\n\n\n缓冲池命中率\nBuffer Pool Hit Ratio\n内存是否够用\n\n\n\nRedis\n\n\n\n指标\n含义\n关注点\n\n\n\n\n命中率\nHit / (Hit + Miss)\n缓存有效性\n\n\n内存使用\nused_memory\n是否接近上限\n\n\n连接数\nconnected_clients\n连接池配置\n\n\n阻塞 Key\nblocked_clients\n慢操作\n\n\n\n消息队列（Kafka/RabbitMQ）\n\n\n\n指标\n含义\n关注点\n\n\n\n\n堆积量\n未消费消息数\n消费者是否跟得上\n\n\n生产速率\n每秒写入消息数\n生产压力\n\n\n消费速率\n每秒消费消息数\n消费能力\n\n\n延迟\n消息从生产到消费的时间\n实时性\n\n\n\n4.4 JVM 指标（Java 应用）\n\n\n\n指标\n含义\n关注点\n\n\n\n\n堆内存\nHeap 使用量\n是否频繁接近上限\n\n\nGC 次数\nYoung GC / Full GC\nFull GC 频繁说明有问题\n\n\nGC 时间\n每次 GC 耗时\n影响 RT\n\n\n线程数\n活跃线程数量\n线程池是否够用\n\n\n\n\n五、常用工具\n5.1 压测工具\n\n\n\n工具\n特点\n适用场景\n\n\n\n\nJMeter\nGUI + 脚本，功能全\n复杂业务场景、协议多\n\n\nLocust\nPython 编写脚本\n开发友好、灵活\n\n\nwrk\n命令行，性能极高\n简单接口、极限压测\n\n\nab\nApache 自带，简单\n快速验证\n\n\nk6\nJS 脚本，现代化\nCI/CD 集成\n\n\nGatling\nScala，报告漂亮\n自动化、报告要求高\n\n\n\n5.2 监控工具\n\n\n\n工具\n用途\n\n\n\n\nPrometheus + Grafana\n指标采集 + 可视化\n\n\nnode_exporter\n主机资源监控\n\n\ncAdvisor\n容器监控\n\n\nArthas\nJava 应用诊断\n\n\nperf / FlameGraph\nCPU 火焰图\n\n\n\n5.3 分析工具\n\n\n\n工具\n用途\n\n\n\n\n慢查询日志\n定位慢 SQL\n\n\nExplain\n分析 SQL 执行计划\n\n\njstack\nJava 线程 dump\n\n\njmap\nJava 内存 dump\n\n\nMAT\n内存泄漏分析\n\n\n\n\n六、性能测试流程\n6.1 标准流程\n1. 需求分析   ├── 测试目标是什么？（TPS 达到 1000？RT &lt; 200ms？）   ├── 测试哪些场景？   └── 测试环境要求？2. 环境准备   ├── 测试环境搭建（尽量接近生产）   ├── 监控部署（Prometheus + Grafana）   ├── 数据准备（测试数据量级）   └── 压测工具准备3. 脚本开发   ├── 接口脚本编写   ├── 参数化配置   ├── 关联处理   └── 脚本调试验证4. 执行测试   ├── 基准测试（摸底）   ├── 负载测试（验证目标）   ├── 压力测试（找极限）   └── 稳定性测试（长时间）5. 结果分析   ├── 指标是否达标   ├── 瓶颈在哪里   └── 优化建议6. 测试报告   ├── 测试结论   ├── 数据图表   └── 问题和建议\n6.2 瓶颈定位思路\nRT 变长 / TPS 上不去    │    ├─ CPU 高？    │   ├─ user 高 → 代码问题（算法、死循环）    │   └─ iowait 高 → 磁盘问题    │    ├─ 内存高？    │   ├─ 持续上涨 → 内存泄漏    │   └─ GC 频繁 → 堆内存不够    │    ├─ CPU/内存都不高？    │   ├─ 数据库慢查询？    │   ├─ 连接池打满？    │   ├─ 锁竞争？    │   └─ 外部依赖慢？    │    └─ 网络？        ├─ 带宽打满        └─ 连接数耗尽\n\n七、Q&amp;A\n7.1 基础问题\nQ：你们性能测试关注哪些指标？\n\n三层：业务指标（RT、TPS、错误率）、系统资源（CPU、内存、IO、网络）、中间件指标（数据库、缓存）。重点是把指标放在同一时间轴上看，找到瓶颈。\n\nQ：RT 看平均值还是 P99？\n\nP99 更重要。平均值会被大量正常请求拉低，掩盖长尾问题。比如平均 100ms，但 P99 是 2s，说明有 1% 用户体验很差。\n\nQ：TPS 和 QPS 的区别？\n\nTPS 是事务，一个事务可能包含多个请求；QPS 是纯请求数。接口压测一般说 QPS，业务压测说 TPS。\n\n7.2 场景问题\nQ：你们预估的 QPS 是怎么得出的？\n\n两种方法：1）看生产监控历史峰值；2）业务推算：日活 × 人均请求数 ÷ 集中时段秒数，再乘 2~3 倍余量。\n\nQ：混合场景怎么设计？\n\n分析生产日志或埋点数据，统计各接口调用比例，按比例配置并发。比如浏览 60%、搜索 25%、下单 5%。\n\nQ：秒杀场景怎么测？\n\n用集合点让请求同时发出，关注：1）限流是否生效；2）库存一致性；3）系统是否雪崩。\n\nQ：稳定性测试发现过什么问题？\n\n内存泄漏（内存持续上涨不释放）、连接泄漏（连接数持续增长）、GC 时间变长、RT 逐渐上涨。\n\n7.3 定位问题\nQ：TPS 上不去，怎么排查？\n\n先看资源：CPU、内存、IO 哪个高。如果都不高，看数据库慢查询、连接池、锁竞争、外部依赖。\n\nQ：CPU 高怎么定位？\n\n看是 user 高还是 iowait 高。user 高用火焰图找热点代码；iowait 高说明磁盘是瓶颈。\n\nQ：内存泄漏怎么定位？\n\n多次 dump 内存快照，用 MAT 对比，看哪些对象持续增长。\n\n\n八、实战检查清单\n测试前\n\n 明确测试目标（TPS、RT、错误率要求）\n 测试环境配置记录（CPU、内存、带宽）\n 监控部署完成（能看到实时数据）\n 测试数据准备（数量级合理）\n 脚本调试通过（单次请求正常）\n\n测试中\n\n 逐步加压，不要一上来就拉满\n 实时观察监控，发现异常及时记录\n 每轮测试记录：并发数、TPS、RT、错误率、资源使用\n 出现拐点时停下来分析\n\n测试后\n\n 整理各轮数据，画趋势图\n 定位瓶颈点\n 输出测试报告\n 提出优化建议\n\n\n九、附录：常用命令速查\n# CPUtop                    # 整体情况vmstat 1               # 每秒刷新mpstat -P ALL 1        # 每个核心# 内存free -h                # 内存概况top -o %MEM            # 按内存排序# 磁盘iostat -x 1            # IO 详情iotop                  # IO 排行# 网络iftop                  # 带宽监控netstat -ant | wc -l   # 连接数ss -s                  # 连接统计# 进程ps aux --sort=-%cpu    # CPU 排行ps aux --sort=-%mem    # 内存排行# Javajstat -gc &lt;pid&gt; 1000   # GC 监控jstack &lt;pid&gt;           # 线程 dumpjmap -heap &lt;pid&gt;       # 堆内存概况\n\n总结\n性能测试的本质是：给系统施加压力，观察表现，找到瓶颈，指导优化。\n记住这个思考框架：\n目标 → 场景 → 指标 → 执行 → 分析 → 优化\n不是为了压测而压测，而是为了回答业务问题：系统能不能扛住？扛不住的话问题在哪？\n","tags":["测试"]},{"title":"testzk123","url":"/2025/07/testzk/","content":"1.新建文章\nhexo new &quot;blog_operation_manual&quot;\n2.直接部署\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n3.在 hexo-admin 中编辑文章内容\n(1)hexo s -d\n(2)进入localhost:4000/admin 页面编辑内容；setting 里设置图片存放在当前文章项目目录下\n","tags":["Python","test"]},{"title":"配置并使用使用Typora编写文章","url":"/2025/07/tpyora-writing-blog/","content":"一、配置\n1.配置 hexo 启动资源文件夹\ncd ~/my-blogvi _config.yml\n修改和追加：\npost_asset_folder: true           # 你已经启用，确认仍为 truemarked:  prependRoot: true               # 给路径自动加站点根  postAsset: true                 # &lt;—— 关键：让图片指向对应文章目录\n2.确认依赖\nnpm uninstall hexo-asset-image      # 旧插件先卸掉，防止冲突npm install hexo-renderer-marked@latest --save\n3.配置 typora 图片设置\n打开 typora-设置-图像：\n(1)插入图片时：选择【复制到指定路径】\n(2)图片存储路径：./${filename}\n\n二、开写\n1.新建文章\nhexo new &quot;working_notes&quot;\n2.直接部署\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n3.编辑内容\n使用Typora打开working_notes.md文件编辑即可，创建文章时终端会显示md文件路径\n\n三、额外配置\n1.设置图标\n(1)图标网站找一个图标，用 gpt 制作成32*32大小，将图片存在source/images/中，命名为favicon.png\n\n(2)编辑themes/typography/layout/partial/head.pug，原内容是href=“images/favicon.png, xxx”，添加一个/\n\n(3)去看看 themes/typography/source/images 里是否有 favicon.png；如果没有，就从现有图标处复制一份放进去\n","tags":["test","tpyora"]},{"title":"一键安装 Ghostty + Starship 配置","url":"/2025/08/ghostty-starship-config/","content":"#!/bin/bash# 一键安装 Ghostty + Starship 配置 (适用于 macOS + zsh)set -eecho &quot;&gt;&gt;&gt; 检查 Homebrew&quot;if ! command -v brew &amp;&gt;/dev/null; then  echo &quot;未检测到 Homebrew，请先安装: https://brew.sh/&quot;  exit 1fiecho &quot;&gt;&gt;&gt; 安装 starship&quot;brew install starshipecho &quot;&gt;&gt;&gt; 安装 Nerd Font (JetBrainsMono)&quot;brew tap homebrew/cask-fontsbrew install --cask font-jetbrains-mono-nerd-fontecho &quot;&gt;&gt;&gt; 创建配置目录&quot;mkdir -p ~/.config/ghosttymkdir -p ~/.configecho &quot;&gt;&gt;&gt; 写入 Ghostty 配置&quot;cat &gt; ~/.config/ghostty/config &lt;&lt; &#x27;EOF&#x27;# ===== Ghostty: Gruvbox Rainbow + Nerd Font =====# --- 字体 ---font-family = &quot;JetBrainsMono Nerd Font&quot;font-size = 14# Gruvbox Rainbow 配色background = #282828foreground = #ebdbb2cursor-color = #d79921cursor-text = #282828selection-background = #504945selection-foreground = #ebdbb2# ANSI 颜色表palette = 0=#282828palette = 1=#fb4934palette = 2=#b8bb26palette = 3=#fabd2fpalette = 4=#83a598palette = 5=#d3869bpalette = 6=#8ec07cpalette = 7=#ebdbb2palette = 8=#928374palette = 9=#fb4934palette = 10=#b8bb26palette = 11=#fabd2fpalette = 12=#83a598palette = 13=#d3869bpalette = 14=#8ec07cpalette = 15=#ebdbb2EOFecho &quot;&gt;&gt;&gt; 写入 Starship 配置&quot;mkdir -p ~/.configcat &gt; ~/.config/starship.toml &lt;&lt; &#x27;EOF&#x27;# ===== Starship Prompt 配置 =====add_newline = falseformat = &quot;&quot;&quot;[](#9A348E)\\$os\\$username\\[](bg:#DA627D fg:#9A348E)\\$directory\\[](fg:#DA627D bg:#FCA17D)\\$git_branch\\$git_status\\[](fg:#FCA17D bg:#86BBD8)\\$nodejs\\[](fg:#86BBD8 bg:#06969A)\\$time\\[ ](fg:#06969A)\\&quot;&quot;&quot;[os]disabled = falsestyle = &quot;bg:#9A348E fg:#ffffff&quot;[username]style_user = &quot;bg:#9A348E fg:#ffffff&quot;show_always = true[directory]style = &quot;bg:#DA627D fg:#ffffff&quot;truncation_length = 3truncate_to_repo = false[git_branch]style = &quot;bg:#FCA17D fg:#000000&quot;[git_status]style = &quot;bg:#FCA17D fg:#000000&quot;[nodejs]symbol = &quot;⬢ &quot;style = &quot;bg:#86BBD8 fg:#000000&quot;[time]disabled = falsetime_format = &quot;%H:%M&quot;style = &quot;bg:#06969A fg:#ffffff&quot;EOFecho &quot;&gt;&gt;&gt; 配置 zsh 自动加载 starship&quot;if ! grep -q &#x27;eval &quot;$(starship init zsh)&quot;&#x27; ~/.zshrc; then  echo &#x27;eval &quot;$(starship init zsh)&quot;&#x27; &gt;&gt; ~/.zshrcfiecho &quot;&gt;&gt;&gt; 完成！请重启终端 (Ghostty) 查看效果 🎉&quot;\n使用方法：\nchmod +x setup_ghostty_starship.sh./setup_ghostty_starship.sh\n\n","tags":["工具"]},{"title":"tmux命令","url":"/2026/01/tmux/","content":"Tmux 常用命令速查表\n核心机制：前缀键 (Prefix Key)\n所有快捷键操作前，必须先按下“扳机”：Ctrl + b (松开后再按后续按键)。\n1. 会话管理 (Session Management)\n在普通终端 (Terminal) 中执行：\n\n\n\n动作\n命令\n说明\n\n\n\n\n新建会话\ntmux new -s &lt;名字&gt;\n创建一个有名字的房间 (例如 tmux new -s claude)\n\n\n列出会话\ntmux ls\n查看后台有哪些房间在运行\n\n\n回到会话\ntmux attach -t &lt;名字&gt;\n重新连接回指定的房间 (简写 tmux a -t &lt;名字&gt;)\n\n\n彻底删除\ntmux kill-session -t &lt;名字&gt;\n在外部强制关闭某个房间\n\n\n\n在 Tmux 内部操作：\n\n\n\n动作\n快捷键/命令\n说明\n\n\n\n\n暂时离开\n前缀键 + d\nDetach。人走，房间留着，程序继续跑\n\n\n彻底结束\n输入 exit 或 Ctrl+d\n关门熄灯，结束当前面板/会话\n\n\n\n2. 屏幕切分 (Pane Management)\n注意：操作前需先按前缀键 Ctrl + b\n\n\n\n动作\n快捷键\n记忆法\n\n\n\n\n左右切分\n% (Shift + 5)\n斜杠 / 把屏幕分两半\n\n\n上下切分\n&quot; (Shift + ')\n引号上下两点，代表上下分\n\n\n切换光标\n方向键 (⬆️⬇️⬅️➡️)\n想去哪边按哪边\n\n\n\n3.设置鼠标移动!!!\ntmux set -g mouse on 回车后，你就可以直接用鼠标滚轮滚动查看历史了，点击面板也会自动切换焦点\n"},{"title":"工作杂记","url":"/2025/08/working-notes/","content":"1.开启 shadowrocket 后，pip3 安装第三方包失败\n\n在终端执行运行(会调用官方安装包自带的证书修复脚本)：\nopen &quot;/Applications/Python 3.13/Install Certificates.command&quot;\n2.设置悬停菜单常驻显示，方便元素定位\n\n","tags":["python"]}]